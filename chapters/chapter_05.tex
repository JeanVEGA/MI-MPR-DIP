\chapter{Chosen technologies}\label{technologies}

	This chapter describes pros and cons of available tools, frameworks and architectural patterns, that may be used and
	explains why and which technologies I finally selected.
	
	One of the non-functional requirements from the previous chapter \ref{NF03} talks about technologies, which should be
	used. The truth is that NF03 was back-added after discussion described in this chapter.

	\section{REST vs. SOAP}
	
	Although implementing a RESTful API is one of the main topics of this master's thesis, it is good to compare other
	possibilities too. Currently the most commonly used technology to build SOA in addition to REST is SOAP. So what are
	the differences between them? Why should not I use SOAP, when thousands of enterprise systems are using it?
	
	Sometimes people talk about SOAP like it was something that is deprecated, or even dead and REST is its successor and
	is much better and modern. This is not true and not even part of it. REST is no revolution in SOA, but rather
	an evolution. SOAP has its place when it comes to a question of implementing services or APIs and so does REST. The
	main difference is: \textbf{SOAP} is aimed for \textbf{server-server} communication and \textbf{REST} is more suitable
	for \textbf{client-server} communication.
	
	Let's forget about the RESTful API requirement and make it just an API. What are the pros and cons of REST, resp. SOAP
	if I could choose one or the another on my own? The only things that I have to keep in mind: I'm implementing an API
	for admission processing and I have two different API consumers using two various platforms \ref{sec:who_will_use}.
	
	\begin{table}[h]\centering
	 	\begin{minipage}{12.9cm}
		\begin{tabular}{p{2cm}|p{4.75cm}|p{4.75cm}}
		\hline
		& REST & SOAP\\
		\hline
		Data Format & XML, JSON, YAML, \ldots & XML \\
		Transport & agnostic, but very tightly coupled with HTTP, unlikely to use anything else & agnostic \\
		Error handling & implementation specific & built in \\
		Primary use & client-server directly & server-server, possibly via mediators \\
		\verb|CRUD|\footnote{Create Read Update Delete} & HTTP methods & implementation specific \\
		Interface description & text description, XSD for XML representation & standardized WSDL, optional XSD \\
		Tools availability & lacking, partial & outstanding \\
		Security & HTTPS, implementation specific  & built in, WS-Security \\
		\hline
		Pros & Lightweight & Standards \\
			 & Space saving formats & Extensible \\
			 & Easy to learn & Tool support \\
			 &  & Type checking \\
			 &  & Rigid \\
		Cons & HTTP dependency & Bloating data format \\
			 & Lacking standards & Complexity and learning curve \\
			 & Lacking tools &  \\
			 & Assumes point-to-point use &  \\
		\end{tabular}
	    \renewcommand{\footnoterule}{}
	    \end{minipage}
	\caption{REST vs. SOAP properties}
	\label{tab:rest_vs_soap}
	\end{table}
	
	Does not look very good for REST from the overview above. Using simple math, it has less pros and more cons. But does
	it mean that SOAP should be chosen for API that Přiříz project needs?
	
	Android team uses a mobile phone device, which is definitely a client. What about the Web interface? I am not sure
	about the implementation, but from my point of view, it should be a thin client, which stores only necessary runtime
	data for its own needs. No need to synchronize any other data, just consume and present. This means \textbf{two
	clients} will be using the API.
	
	Web interface will be deployed on its own application server somewhere inside the CTU's infrastructure and will use
	fast network connection. On the other hand, Android device will be able to use some wireless fast network - best case.
	But what if the mobile application will be forced to rely on a slower carrier network? EDGE - worst case. The API
	should then try to save as much traffic as it can. XML full of namespaces that \textbf{SOAP} happily uses is
	\textbf{not} the \textbf{right} way, though.
	
	HTTP dependency is not a problem, I would use SOAP over HTTP anyway. Lack of standards is a matter of good design. This
	is why I have to be very careful when exposing new functions or data models. It does not mean that this issue would not
	effect SOAP design.
	
	Lack of tools is a thing that bothers me a bit. If I agree on standardized approach with other teams and we involve a
	bit of communication, hopefully we can get over this one.
	
	So far for the cons of REST. Which pros of SOAP will I miss, if I decided to use REST? Just the tool support.
	
	To sum up, RESTful API would win and therefore I am happy with the original requirement.
	
	\section{BPEL vs. BPMN}
	
	When I started to collection information about BPM and its standards, I found many discussions about older BPEL vs.
	relatively new BPMN, currently available in BPMN 2.0 specification.
	
	\cite{bpm} says that the only standard worth considering is BPEL. This information is a few years old and by the time a
	another player has shown up. BPMN 2.0 became a solid competitor to BPEL.
	
	\cite{oracle_architecture_standards}
	BPEL and BPMN are both \uv{languages} or \uv{notations} for describing and executing business processes. Both are open
	standards. Most business process engines will support one or the other of these languages.
	
	It turns out that BPEL is really well suited to modeling some kinds of processes and BPMN is really well suited to
	modeling other kinds of processes. Of course there is a pretty significant overlap where either will do a great job.
	
	\cite{ms_bpmn_bpel}
	BPMN 2.0 is now a business model that can be executed after implementation details are added. BPMN favors the business
	user, even though a developer can \uv{refine with execution semantics} to make it executable. It is graph based, and
	incorporates user swim lanes, which makes it effective for modelling end to end business processes. 
	
	BPMN 2.0 introduces a standardized file format (previously is was proprietary or converted to XPDL). BPMN looks like a
	version of BPEL where the assigns are tucked away into other activities to clean up the diagram.

	BPEL's nature is still service orchestration, and will be great for building composite services and
	integrating with applications. BPEL will still probably be the choice for developers, where BPMN will be good for the
	pure decision layer and \textbf{Human Task interaction}.
	
	\cite[p.~1]{bpmn}
	The primary goal of BPMN is to provide a notation that is readily understandable by all business users, from the
	business analysts that create the initial drafts of the processes, to the technical developers responsible for
	implementing the technology that will perform those processes, and finally, to the business people who will manage and
	monitor those processes. Thus, BPMN creates a standardized bridge for the gap between the business process design and
	process implementation.
	Another goal  is to ensure that XML languages designed for the execution of \textbf{business processes}, such as
	\gls{WSBPEL}, \textbf{can be visualized} with a business-oriented notation.
	
	Human Task interaction is exactly what admission processing is looking for and visualization of the process is a must.
	It is expected that further modifications of business process model will be performed by non-developers. Therefore an
	user friendly visual modelling tool is required. That is why BPMN 2.0 looks like a good choice. Luckily jBPM, which was
	chosen as a primary technology for this master's thesis, fully implements BPMN 2.0 standard.
	
	\section{Dependency management}
	
	One of the myths about Java development that is well established among people talks about some kind of JAR hell.
	Basically it is a nickname for class loading problem, which used to be an issue some time ago. Nowadays there are tons
	of tools available that effectively solve such issues, one just needs to keep following the progress.
	
	A solution is to use standardized Java project structure, right build tools and dependency management tools. There are
	dozens of such utilities but the two mainstream ones are:
	
	\begin{itemize}
		\item Apache Ant + Apache Ivy

		\cite{ant}		
		Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as
		targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
		Ant supplies a number of built-in tasks allowing to compile, assemble, test and run Java applications.
		
		Ant is extremely flexible and does not impose coding conventions or directory layouts to the Java projects which adopt
		it as a build tool.

		Software development projects looking for a solution combining build tool and dependency management can use Ant in
		combination with Apache Ivy.
		
		\cite{ivy}
		Apache Ivy is a dependency manager oriented toward Java dependency management, although it can be used to manage
		dependencies of any kind. Apache Ivy is integrated with Apache Ant, the most popular Java build management system, so
		Apache Ivy follows Apache Ant design principles.
		\item Apache Maven
	  
		\cite{maven}
	  	Apache Maven is a software project management and comprehension tool. Based on the concept of a \gls{POM}, Maven can
	  	manage a project's build, reporting and documentation from a central piece of information.
	  
	  	Maven's primary goal is to allow a developer to comprehend the complete state of a development effort in the
	  	shortest period of time. In order to attain this goal there are several areas of concern that Maven attempts to deal
	  	with:
		
		\begin{itemize}
			\item Making the build process easy
			\item Providing a uniform build system
			\item Providing quality project information
			\item Providing guidelines for best practices development
			\item Allowing transparent migration to new features
		\end{itemize}
	\end{itemize}
	
	Combination of Ant and Ivy is suitable for older, already existing Java projects that use Ant scripts for build
	process. Ivy will allow to remove hard copied JAR files and enable dependency management using remote JAR repositories.
	
	Maven 2 on the other hand is currently the most commonly used project management and comprehension tool. Dependency
	management and project build are just a small part of its capabilities.
	
	\section{JAX-RS implementation}
	
	In theoretical part \ref{sec:jaxrs} of this work I briefly described JAX-RS. Standard JVM contains only the JAX-RS
	API, but there is no implementation out of box. Luckily, Java developers community is one of the biggest among
	available enterprise solutions and probably the biggest \gls{OSS} enterprise community.
	One of the advantages of such a number of developers is that there is an endless choice of frameworks, utilities and
	other libraries. When it comes to popular JAX-RS implementations these are worth noticing:
	
	\begin{itemize}
	  \item Apache CXF
	  
	  Very complex, popular and pleasant to use.
	  \item Jersey
	  
	  Oracle's reference implementation.
	  \item RESTeasy
	  
	  From JBoss Community.
	\end{itemize}
	
	Personally I tried Apache CXF and RESTeasy. Although any of the above would work well for RESTful API, I have best
	experience with Apache CXF. It offers much more than just plain JAX-RS implementation. Spring framework integration is
	available, error handling is very neat and makes RESTful API server or client development a breeze.
	
	Moreover it also contains \gls{JAXWS} implementation, which might be useful for future, when SOAP integration is
	required. This will keep REST and SOAP parts consistent across the whole source code.
	
	\section{Spring Core, MVC, Security, \ldots}
	
	
	
	\section{Spring Roo}